datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

/**
 * Aligné sur ta base existante :
 * - Pas d'ENUM pour subscriptionStatus (TEXT en base) → String? @map("subscriptionstatus")
 * - Colonnes physiques en minuscules: createdat/updatedat/subscriptionstatus
 * - UUID générés par la DB: dbgenerated("gen_random_uuid()")
 * - steps par défaut: '[]'::jsonb
 */

model User {
  id                 String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email              String    @unique
  passwordHash       String    @default("")
  stripeCustomerId   String?
  subscriptionEndsAt DateTime? @db.Timestamptz(6)

  // colonnes mappées
  subscriptionStatus String?  @default("trialing") @map("subscriptionstatus")
  createdAt          DateTime @default(now())       @map("createdat") @db.Timestamptz(6)
  updatedAt          DateTime @default(now()) @updatedAt @map("updatedat") @db.Timestamptz(6)

  // relations
  ImportLimit  ImportLimit?
  Recipes      Recipe[]
  RecipeDrafts RecipeDraft[]
}

model Recipe {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @db.Uuid
  title     String
  servings  Int      @default(1)
  steps     Json     @default(dbgenerated("'[]'::jsonb"))
  imageUrl  String?
  notes     String?  @default("")

  createdAt DateTime @default(now()) @map("createdat") @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @map("updatedat") @db.Timestamptz(6)

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  ingredients Ingredient[]

  @@index([userId], map: "idx_recipe_user")
}

model Ingredient {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  recipeId     String   @db.Uuid
  name         String
  quantity     Float    @default(0)
  unit         String
  airtableId   String?
  unitPriceBuy Float?
  costRecipe   Float?
  createdAt    DateTime @default(now()) @db.Timestamptz(6)
  updatedAt    DateTime @default(now()) @db.Timestamptz(6)

  recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([recipeId], map: "idx_ri_recipe")
  @@map("Ingredients") // si la table s’appelle déjà "Ingredients" en base
}

//
// 1:1 strict avec User : on utilise userId comme clé primaire (pas besoin d’un champ id séparé)
//
model ImportLimit {
  userId      String   @id @db.Uuid
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  breakfasts  Int      @default(0)
  lunches     Int      @default(0)
  snacks      Int      @default(0)
  dinners     Int      @default(0)

  periodStart DateTime @default(now()) @db.Timestamptz(6)
  createdAt   DateTime @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime @default(now()) @db.Timestamptz(6)
}

model RecipeDraft {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @db.Uuid

  sourceUrl String?
  title     String?
  imageUrl  String?
  rawText   String?
  parsed    Json?
  status    String   @default("new")

  createdAt DateTime @default(now()) @map("createdat") @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @map("updatedat") @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([userId], map: "idx_recipedraft_user")
}

